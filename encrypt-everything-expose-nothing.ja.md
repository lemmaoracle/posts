---
slug: "encrypt-everything-expose-nothing"
date: "2026.02.28"
category: "Guides"
section: "Essays"
title: "すべてを暗号化し、何も露出しない"
abstract: "Lemma がすべてのドキュメントを AES-GCM で暗号化し、AI が生の PII に触れないようにする仕組み。docHash と CID だけが来歴の安定したアンカーとして公開されます。"
---

## AI パイプラインにおける生データの問題

ほとんどの AI システムはドキュメントを平文で取り込みます。PDF、JSON レコード、API レスポンスが RAG パイプラインに入った瞬間、すべてのフィールド（氏名、住所、給与、診断結果）がモデル、埋め込みストア、データベースにアクセスできる全員に読み取り可能になります。

これは理論上のリスクではありません。ベクトルストアの設定ミス一つで数百万件のレコードが露出し得ます。保存時の暗号化は、アプリケーション層がインデックス化の前にすべてを復号する場合には意味がありません。

## Lemma のドキュメント暗号化

Lemma はすべてのドキュメントをシステムに入る**前に**暗号化し、一切復号しません。

1. ホルダーの公開鍵を取得（DID またはウォレットから導出）。
2. ECDH + HKDF により共有鍵 `K_doc` をハイブリッド暗号化鍵として導出。
3. 生ドキュメントを AES-GCM で暗号化し `encryptedDoc` を生成。
4. 暗号化ブロブを IPFS または Ceramic にオフチェーン保存し、`cid` を取得。
5. `docHash = SHA3-256(encryptedDoc)` を計算し、オンチェーンの主キーとして使用。

以降、Lemma が扱うのは `docHash` と `cid` の2つの識別子のみです。平文がサーバー側で再構成されることはありません。

```typescript
import { encrypt } from "@lemmaoracle/sdk";

const enc = await encrypt(client, {
  payload: rawDoc,
  holderKey: holderPubKey,
});
// enc.docHash → オンチェーンの主キー
// enc.cid    → IPFS/Ceramic のストレージ参照
```

## AI が実際に見るもの

Lemma にクエリする AI エージェントは生のフィールドを受け取りません。代わりに**検証済み属性**を受け取ります。型付けされ、証明され、完全な来歴メタデータを持つファクトです。生ドキュメントは暗号化されたまま残り、AI は ZK 証明と選択的開示の出力を使って作業します。

これにより、RAG パイプラインは生年月日、住所、政府発行 ID 番号を一切見ることなく「このユーザーは 18 歳以上か？」に回答できます。

## docHash と CID で十分な理由

`docHash` は暗号化コンテンツに対する暗号学的コミットメントです。保存されたドキュメントが改ざんされればハッシュが一致しなくなります。`cid` はコンテンツアドレス型の識別子で、正しい鍵を持つ権限者がオリジナルを取得・復号できるようにします。

この2つの値により、Lemma は以下を実現します：

- ドキュメントの存在をオンチェーンにアンカー。
- ZK 証明と選択的開示を特定のドキュメントに紐づけ。
- 権限を持つホルダーが必要時に取得・復号。

生コンテンツが信頼境界を越えることはありません。

## いつ使うか

暗号化ファーストは Lemma のデフォルトです。オプトインする必要はありません。`encrypt()` を呼ぶたびに `docHash`/`cid` ペアが生成され、後続のすべての操作（コミット、証明、開示、登録）は平文ではなくこれらの識別子を参照します。PII、財務記録、医療データ、または仲介者に読まれるべきでないドキュメントを扱うアプリケーションであれば、これが他のすべての基盤となります。
